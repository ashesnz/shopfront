{"ts":1350738533169,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1350738539799,"patch":[[{"diffs":[[1,"/**\r\n * QUnit v1.10.0 - A JavaScript Unit Testing Framework\r\n *\r\n * http://qunitjs.com\r\n *\r\n * Copyright 2012 jQuery Foundation and other contributors\r\n * Released under the MIT license.\r\n * http://jquery.org/license\r\n */\r\n\r\n(function( window ) {\r\n\r\nvar QUnit,\r\n  config,\r\n\tonErrorFnPrev,\r\n\ttestId = 0,\r\n\tfileName = (sourceFromStacktrace( 0 ) || \"\" ).replace(/(:\\d+)+\\)?/, \"\").replace(/.+\\//, \"\"),\r\n\ttoString = Object.prototype.toString,\r\n\thasOwn = Object.prototype.hasOwnProperty,\r\n\t// Keep a local reference to Date (GH-283)\r\n\tDate = window.Date,\r\n\tdefined = {\r\n\tsetTimeout: typeof window.setTimeout !== \"undefined\",\r\n\tsessionStorage: (function() {\r\n\t\tvar x = \"qunit-test-string\";\r\n\t\ttry {\r\n\t\t\tsessionStorage.setItem( x, x );\r\n\t\t\tsessionStorage.removeItem( x );\r\n\t\t\treturn true;\r\n\t\t} catch( e ) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}())\r\n};\r\n\r\nfunction Test( settings ) {\r\n\textend( this, settings );\r\n\tthis.assertions = [];\r\n\tthis.testNumber = ++Test.count;\r\n}\r\n\r\nTest.count = 0;\r\n\r\nTest.prototype = {\r\n\tinit: function() {\r\n\t\tvar a, b, li,\r\n        tests = id( \"qunit-tests\" );\r\n\r\n\t\tif ( tests ) {\r\n\t\t\tb = document.createElement( \"strong\" );\r\n\t\t\tb.innerHTML = this.name;\r\n\r\n\t\t\t// `a` initialized at top of scope\r\n\t\t\ta = document.createElement( \"a\" );\r\n\t\t\ta.innerHTML = \"Rerun\";\r\n\t\t\ta.href = QUnit.url({ testNumber: this.testNumber });\r\n\r\n\t\t\tli = document.createElement( \"li\" );\r\n\t\t\tli.appendChild( b );\r\n\t\t\tli.appendChild( a );\r\n\t\t\tli.className = \"running\";\r\n\t\t\tli.id = this.id = \"qunit-test-output\" + testId++;\r\n\r\n\t\t\ttests.appendChild( li );\r\n\t\t}\r\n\t},\r\n\tsetup: function() {\r\n\t\tif ( this.module !== config.previousModule ) {\r\n\t\t\tif ( config.previousModule ) {\r\n\t\t\t\trunLoggingCallbacks( \"moduleDone\", QUnit, {\r\n\t\t\t\t\tname: config.previousModule,\r\n\t\t\t\t\tfailed: config.moduleStats.bad,\r\n\t\t\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\r\n\t\t\t\t\ttotal: config.moduleStats.all\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t\tconfig.previousModule = this.module;\r\n\t\t\tconfig.moduleStats = { all: 0, bad: 0 };\r\n\t\t\trunLoggingCallbacks( \"moduleStart\", QUnit, {\r\n\t\t\t\tname: this.module\r\n\t\t\t});\r\n\t\t} else if ( config.autorun ) {\r\n\t\t\trunLoggingCallbacks( \"moduleStart\", QUnit, {\r\n\t\t\t\tname: this.module\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tconfig.current = this;\r\n\r\n\t\tthis.testEnvironment = extend({\r\n\t\t\tsetup: function() {},\r\n\t\t\tteardown: function() {}\r\n\t\t}, this.moduleTestEnvironment );\r\n\r\n\t\trunLoggingCallbacks( \"testStart\", QUnit, {\r\n\t\t\tname: this.testName,\r\n\t\t\tmodule: this.module\r\n\t\t});\r\n\r\n\t\t// allow utility functions to access the current test environment\r\n\t\t// TODO why??\r\n\t\tQUnit.current_testEnvironment = this.testEnvironment;\r\n\r\n\t\tif ( !config.pollution ) {\r\n\t\t\tsaveGlobal();\r\n\t\t}\r\n\t\tif ( config.notrycatch ) {\r\n\t\t\tthis.testEnvironment.setup.call( this.testEnvironment );\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry {\r\n\t\t\tthis.testEnvironment.setup.call( this.testEnvironment );\r\n\t\t} catch( e ) {\r\n\t\t\tQUnit.pushFailure( \"Setup failed on \" + this.testName + \": \" + e.message, extractStacktrace( e, 1 ) );\r\n\t\t}\r\n\t},\r\n\trun: function() {\r\n\t\tconfig.current = this;\r\n\r\n\t\tvar running = id( \"qunit-testresult\" );\r\n\r\n\t\tif ( running ) {\r\n\t\t\trunning.innerHTML = \"Running: <br/>\" + this.name;\r\n\t\t}\r\n\r\n\t\tif ( this.async ) {\r\n\t\t\tQUnit.stop();\r\n\t\t}\r\n\r\n\t\tif ( config.notrycatch ) {\r\n\t\t\tthis.callback.call( this.testEnvironment, QUnit.assert );\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tthis.callback.call( this.testEnvironment, QUnit.assert );\r\n\t\t} catch( e ) {\r\n\t\t\tQUnit.pushFailure( \"Died on test #\" + (this.assertions.length + 1) + \" \" + this.stack + \": \" + e.message, extractStacktrace( e, 0 ) );\r\n\t\t\t// else next test will carry the responsibility\r\n\t\t\tsaveGlobal();\r\n\r\n\t\t\t// Restart the tests if they're blocking\r\n\t\t\tif ( config.blocking ) {\r\n\t\t\t\tQUnit.start();\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tteardown: function() {\r\n\t\tconfig.current = this;\r\n\t\tif ( config.notrycatch ) {\r\n\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment );\r\n\t\t\treturn;\r\n\t\t} else {\r\n\t\t\ttry {\r\n\t\t\t\tthis.testEnvironment.teardown.call( this.testEnvironment );\r\n\t\t\t} catch( e ) {\r\n\t\t\t\tQUnit.pushFailure( \"Teardown failed on \" + this.testName + \": \" + e.message, extractStacktrace( e, 1 ) );\r\n\t\t\t}\r\n\t\t}\r\n\t\tcheckPollution();\r\n\t},\r\n\tfinish: function() {\r\n\t\tconfig.current = this;\r\n\t\tif ( config.requireExpects && this.expected == null ) {\r\n\t\t\tQUnit.pushFailure( \"Expected number of assertions to be defined, but expect() was not called.\", this.stack );\r\n\t\t} else if ( this.expected != null && this.expected != this.assertions.length ) {\r\n\t\t\tQUnit.pushFailure( \"Expected \" + this.expected + \" assertions, but \" + this.assertions.length + \" were run\", this.stack );\r\n\t\t} else if ( this.expected == null && !this.assertions.length ) {\r\n\t\t\tQUnit.pushFailure( \"Expected at least one assertion, but none were run - call expect(0) to accept zero assertions.\", this.stack );\r\n\t\t}\r\n\r\n\t\tvar assertion, a, b, i, li, ol,\r\n\t\t\ttest = this,\r\n\t\t\tgood = 0,\r\n\t\t\tbad = 0,\r\n\t\t\ttests = id( \"qunit-tests\" );\r\n\r\n\t\tconfig.stats.all += this.assertions.length;\r\n\t\tconfig.moduleStats.all += this.assertions.length;\r\n\r\n\t\tif ( tests ) {\r\n\t\t\tol = document.createElement( \"ol\" );\r\n\r\n\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\r\n\t\t\t\tassertion = this.assertions[i];\r\n\r\n\t\t\t\tli = document.createElement( \"li\" );\r\n\t\t\t\tli.className = assertion.result ? \"pass\" : \"fail\";\r\n\t\t\t\tli.innerHTML = assertion.message || ( assertion.result ? \"okay\" : \"failed\" );\r\n\t\t\t\tol.appendChild( li );\r\n\r\n\t\t\t\tif ( assertion.result ) {\r\n\t\t\t\t\tgood++;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbad++;\r\n\t\t\t\t\tconfig.stats.bad++;\r\n\t\t\t\t\tconfig.moduleStats.bad++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// store result when possible\r\n\t\t\tif ( QUnit.config.reorder && defined.sessionStorage ) {\r\n\t\t\t\tif ( bad ) {\r\n\t\t\t\t\tsessionStorage.setItem( \"qunit-test-\" + this.module + \"-\" + this.testName, bad );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsessionStorage.removeItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif ( bad === 0 ) {\r\n\t\t\t\tol.style.display = \"none\";\r\n\t\t\t}\r\n\r\n\t\t\t// `b` initialized at top of scope\r\n\t\t\tb = document.createElement( \"strong\" );\r\n\t\t\tb.innerHTML = this.name + \" <b class='counts'>(<b class='failed'>\" + bad + \"</b>, <b class='passed'>\" + good + \"</b>, \" + this.assertions.length + \")</b>\";\r\n\r\n\t\t\taddEvent(b, \"click\", function() {\r\n\t\t\t\tvar next = b.nextSibling.nextSibling,\r\n\t\t\t\t\tdisplay = next.style.display;\r\n\t\t\t\tnext.style.display = display === \"none\" ? \"block\" : \"none\";\r\n\t\t\t});\r\n\r\n\t\t\taddEvent(b, \"dblclick\", function( e ) {\r\n\t\t\t\tvar target = e && e.target ? e.target : window.event.srcElement;\r\n\t\t\t\tif ( target.nodeName.toLowerCase() == \"span\" || target.nodeName.toLowerCase() == \"b\" ) {\r\n\t\t\t\t\ttarget = target.parentNode;\r\n\t\t\t\t}\r\n\t\t\t\tif ( window.location && target.nodeName.toLowerCase() === \"strong\" ) {\r\n\t\t\t\t\twindow.location = QUnit.url({ testNumber: test.testNumber });\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\t\t\t// `li` initialized at top of scope\r\n\t\t\tli = id( this.id );\r\n\t\t\tli.className = bad ? \"fail\" : \"pass\";\r\n\t\t\tli.removeChild( li.firstChild );\r\n\t\t\ta = li.firstChild;\r\n\t\t\tli.appendChild( b );\r\n\t\t\tli.appendChild ( a );\r\n\t\t\tli.appendChild( ol );\r\n\r\n\t\t} else {\r\n\t\t\tfor ( i = 0; i < this.assertions.length; i++ ) {\r\n\t\t\t\tif ( !this.assertions[i].result ) {\r\n\t\t\t\t\tbad++;\r\n\t\t\t\t\tconfig.stats.bad++;\r\n\t\t\t\t\tconfig.moduleStats.bad++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trunLoggingCallbacks( \"testDone\", QUnit, {\r\n\t\t\tname: this.testName,\r\n\t\t\tmodule: this.module,\r\n\t\t\tfailed: bad,\r\n\t\t\tpassed: this.assertions.length - bad,\r\n\t\t\ttotal: this.assertions.length\r\n\t\t});\r\n\r\n\t\tQUnit.reset();\r\n\r\n\t\tconfig.current = undefined;\r\n\t},\r\n\r\n\tqueue: function() {\r\n\t\tvar bad,\r\n\t\t\ttest = this;\r\n\r\n\t\tsynchronize(function() {\r\n\t\t\ttest.init();\r\n\t\t});\r\n\t\tfunction run() {\r\n\t\t\t// each of these can by async\r\n\t\t\tsynchronize(function() {\r\n\t\t\t\ttest.setup();\r\n\t\t\t});\r\n\t\t\tsynchronize(function() {\r\n\t\t\t\ttest.run();\r\n\t\t\t});\r\n\t\t\tsynchronize(function() {\r\n\t\t\t\ttest.teardown();\r\n\t\t\t});\r\n\t\t\tsynchronize(function() {\r\n\t\t\t\ttest.finish();\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\t// `bad` initialized at top of scope\r\n\t\t// defer when previous test run passed, if storage is available\r\n\t\tbad = QUnit.config.reorder && defined.sessionStorage &&\r\n\t\t\t\t\t\t+sessionStorage.getItem( \"qunit-test-\" + this.module + \"-\" + this.testName );\r\n\r\n\t\tif ( bad ) {\r\n\t\t\trun();\r\n\t\t} else {\r\n\t\t\tsynchronize( run, true );\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// Root QUnit object.\r\n// `QUnit` initialized at top of scope\r\nQUnit = {\r\n\r\n\t// call on start of module test to prepend name to all tests\r\n\tmodule: function( name, testEnvironment ) {\r\n\t\tconfig.currentModule = name;\r\n\t\tconfig.currentModuleTestEnvironment = testEnvironment;\r\n\t\tconfig.modules[name] = true;\r\n\t},\r\n\r\n\tasyncTest: function( testName, expected, callback ) {\r\n\t\tif ( arguments.length === 2 ) {\r\n\t\t\tcallback = expected;\r\n\t\t\texpected = null;\r\n\t\t}\r\n\r\n\t\tQUnit.test( testName, expected, callback, true );\r\n\t},\r\n\r\n\ttest: function( testName, expected, callback, async ) {\r\n\t\tvar test,\r\n\t\t\tname = \"<span class='test-name'>\" + escapeInnerText( testName ) + \"</span>\";\r\n\r\n\t\tif ( arguments.length === 2 ) {\r\n\t\t\tcallback = expected;\r\n\t\t\texpected = null;\r\n\t\t}\r\n\r\n\t\tif ( config.currentModule ) {\r\n\t\t\tname = \"<span class='module-name'>\" + config.currentModule + \"</span>: \" + name;\r\n\t\t}\r\n\r\n\t\ttest = new Test({\r\n\t\t\tname: name,\r\n\t\t\ttestName: testName,\r\n\t\t\texpected: expected,\r\n\t\t\tasync: async,\r\n\t\t\tcallback: callback,\r\n\t\t\tmodule: config.currentModule,\r\n\t\t\tmoduleTestEnvironment: config.currentModuleTestEnvironment,\r\n\t\t\tstack: sourceFromStacktrace( 2 )\r\n\t\t});\r\n\r\n\t\tif ( !validTest( test ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttest.queue();\r\n\t},\r\n\r\n\t// Specify the number of expected assertions to gurantee that failed test (no assertions are run at all) don't slip through.\r\n\texpect: function( asserts ) {\r\n\t\tif (arguments.length === 1) {\r\n\t\t\tconfig.current.expected = asserts;\r\n\t\t} else {\r\n\t\t\treturn config.current.expected;\r\n\t\t}\r\n\t},\r\n\r\n\tstart: function( count ) {\r\n\t\tconfig.semaphore -= count || 1;\r\n\t\t// don't start until equal number of stop-calls\r\n\t\tif ( config.semaphore > 0 ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// ignore if start is called more often then stop\r\n\t\tif ( config.semaphore < 0 ) {\r\n\t\t\tconfig.semaphore = 0;\r\n\t\t}\r\n\t\t// A slight delay, to avoid any current callbacks\r\n\t\tif ( defined.setTimeout ) {\r\n\t\t\twindow.setTimeout(function() {\r\n\t\t\t\tif ( config.semaphore > 0 ) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif ( config.timeout ) {\r\n\t\t\t\t\tclearTimeout( config.timeout );\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconfig.blocking = false;\r\n\t\t\t\tprocess( true );\r\n\t\t\t}, 13);\r\n\t\t} else {\r\n\t\t\tconfig.blocking = false;\r\n\t\t\tprocess( true );\r\n\t\t}\r\n\t},\r\n\r\n\tstop: function( count ) {\r\n\t\tconfig.semaphore += count || 1;\r\n\t\tconfig.blocking = true;\r\n\r\n\t\tif ( config.testTimeout && defined.setTimeout ) {\r\n\t\t\tclearTimeout( config.timeout );\r\n\t\t\tconfig.timeout = window.setTimeout(function() {\r\n\t\t\t\tQUnit.ok( false, \"Test timed out\" );\r\n\t\t\t\tconfig.semaphore = 1;\r\n\t\t\t\tQUnit.start();\r\n\t\t\t}, config.testTimeout );\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// Asssert helpers\r\n// All of these must call either QUnit.push() or manually do:\r\n// - runLoggingCallbacks( \"log\", .. );\r\n// - config.current.assertions.push({ .. });\r\nQUnit.assert = {\r\n\t/**\r\n\t * Asserts rough true-ish result.\r\n\t * @name ok\r\n\t * @function\r\n\t * @example ok( \"asdfasdf\".length > 5, \"There must be at least 5 chars\" );\r\n\t */\r\n\tok: function( result, msg ) {\r\n\t\tif ( !config.current ) {\r\n\t\t\tthrow new Error( \"ok() assertion outside test context, was \" + sourceFromStacktrace(2) );\r\n\t\t}\r\n\t\tresult = !!result;\r\n\r\n\t\tvar source,\r\n\t\t\tdetails = {\r\n\t\t\t\tmodule: config.current.module,\r\n\t\t\t\tname: config.current.testName,\r\n\t\t\t\tresult: result,\r\n\t\t\t\tmessage: msg\r\n\t\t\t};\r\n\r\n\t\tmsg = escapeInnerText( msg || (result ? \"okay\" : \"failed\" ) );\r\n\t\tmsg = \"<span class='test-message'>\" + msg + \"</span>\";\r\n\r\n\t\tif ( !result ) {\r\n\t\t\tsource = sourceFromStacktrace( 2 );\r\n\t\t\tif ( source ) {\r\n\t\t\t\tdetails.source = source;\r\n\t\t\t\tmsg += \"<table><tr class='test-source'><th>Source: </th><td><pre>\" + escapeInnerText( source ) + \"</pre></td></tr></table>\";\r\n\t\t\t}\r\n\t\t}\r\n\t\trunLoggingCallbacks( \"log\", QUnit, details );\r\n\t\tconfig.current.assertions.push({\r\n\t\t\tresult: result,\r\n\t\t\tmessage: msg\r\n\t\t});\r\n\t},\r\n\r\n\t/**\r\n\t * Assert that the first two arguments are equal, with an optional message.\r\n\t * Prints out both actual and expected values.\r\n\t * @name equal\r\n\t * @function\r\n\t * @example equal( format( \"Received {0} bytes.\", 2), \"Received 2 bytes.\", \"format() replaces {0} with next argument\" );\r\n\t */\r\n\tequal: function( actual, expected, message ) {\r\n\t\tQUnit.push( expected == actual, actual, expected, message );\r\n\t},\r\n\r\n\t/**\r\n\t * @name notEqual\r\n\t * @function\r\n\t */\r\n\tnotEqual: function( actual, expected, message ) {\r\n\t\tQUnit.push( expected != actual, actual, expected, message );\r\n\t},\r\n\r\n\t/**\r\n\t * @name deepEqual\r\n\t * @function\r\n\t */\r\n\tdeepEqual: function( actual, expected, message ) {\r\n\t\tQUnit.push( QUnit.equiv(actual, expected), actual, expected, message );\r\n\t},\r\n\r\n\t/**\r\n\t * @name notDeepEqual\r\n\t * @function\r\n\t */\r\n\tnotDeepEqual: function( actual, expected, message ) {\r\n\t\tQUnit.push( !QUnit.equiv(actual, expected), actual, expected, message );\r\n\t},\r\n\r\n\t/**\r\n\t * @name strictEqual\r\n\t * @function\r\n\t */\r\n\tstrictEqual: function( actual, expected, message ) {\r\n\t\tQUnit.push( expected === actual, actual, expected, message );\r\n\t},\r\n\r\n\t/**\r\n\t * @name notStrictEqual\r\n\t * @function\r\n\t */\r\n\tnotStrictEqual: function( actual, expected, message ) {\r\n\t\tQUnit.push( expected !== actual, actual, expected, message );\r\n\t},\r\n\r\n\tthrows: function( block, expected, message ) {\r\n\t\tvar actual,\r\n\t\t\tok = false;\r\n\r\n\t\t// 'expected' is optional\r\n\t\tif ( typeof expected === \"string\" ) {\r\n\t\t\tmessage = expected;\r\n\t\t\texpected = null;\r\n\t\t}\r\n\r\n\t\tconfig.current.ignoreGlobalErrors = true;\r\n\t\ttry {\r\n\t\t\tblock.call( config.current.testEnvironment );\r\n\t\t} catch (e) {\r\n\t\t\tactual = e;\r\n\t\t}\r\n\t\tconfig.current.ignoreGlobalErrors = false;\r\n\r\n\t\tif ( actual ) {\r\n\t\t\t// we don't want to validate thrown error\r\n\t\t\tif ( !expected ) {\r\n\t\t\t\tok = true;\r\n\t\t\t// expected is a regexp\r\n\t\t\t} else if ( QUnit.objectType( expected ) === \"regexp\" ) {\r\n\t\t\t\tok = expected.test( actual );\r\n\t\t\t// expected is a constructor\r\n\t\t\t} else if ( actual instanceof expected ) {\r\n\t\t\t\tok = true;\r\n\t\t\t// expected is a validation function which returns true is validation passed\r\n\t\t\t} else if ( expected.call( {}, actual ) === true ) {\r\n\t\t\t\tok = true;\r\n\t\t\t}\r\n\r\n\t\t\tQUnit.push( ok, actual, null, message );\r\n\t\t} else {\r\n\t\t\tQUnit.pushFailure( message, null, 'No exception was thrown.' );\r\n\t\t}\r\n\t}\r\n};\r\n\r\n/**\r\n * @deprecate since 1.8.0\r\n * Kept assertion helpers in root for backwards compatibility\r\n */\r\nextend( QUnit, QUnit.assert );\r\n\r\n/**\r\n * @deprecated since 1.9.0\r\n * Kept global \"raises()\" for backwards compatibility\r\n */\r\nQUnit.raises = QUnit.assert.throws;\r\n\r\n/**\r\n * @deprecated since 1.0.0, replaced with error pushes since 1.3.0\r\n * Kept to avoid TypeErrors for undefined methods.\r\n */\r\nQUnit.equals = function() {\r\n\tQUnit.push( false, false, false, \"QUnit.equals has been deprecated since 2009 (e88049a0), use QUnit.equal instead\" );\r\n};\r\nQUnit.same = function() {\r\n\tQUnit.push( false, false, false, \"QUnit.same has been deprecated since 2009 (e88049a0), use QUnit.deepEqual instead\" );\r\n};\r\n\r\n// We want access to the constructor's prototype\r\n(function() {\r\n\tfunction F() {}\r\n\tF.prototype = QUnit;\r\n\tQUnit = new F();\r\n\t// Make F QUnit's constructor so that we can add to the prototype later\r\n\tQUnit.constructor = F;\r\n}());\r\n\r\n/**\r\n * Config object: Maintain internal state\r\n * Later exposed as QUnit.config\r\n * `config` initialized at top of scope\r\n */\r\nconfig = {\r\n\t// The queue of tests to run\r\n\tqueue: [],\r\n\r\n\t// block until document ready\r\n\tblocking: true,\r\n\r\n\t// when enabled, show only failing tests\r\n\t// gets persisted through sessionStorage and can be changed in UI via checkbox\r\n\thidepassed: false,\r\n\r\n\t// by default, run previously failed tests first\r\n\t// very useful in combination with \"Hide passed tests\" checked\r\n\treorder: true,\r\n\r\n\t// by default, modify document.title when suite is done\r\n\taltertitle: true,\r\n\r\n\t// when enabled, all tests must call expect()\r\n\trequireExpects: false,\r\n\r\n\t// add checkboxes that are persisted in the query-string\r\n\t// when enabled, the id is set to `true` as a `QUnit.config` property\r\n\turlConfig: [\r\n\t\t{\r\n\t\t\tid: \"noglobals\",\r\n\t\t\tlabel: \"Check for Globals\",\r\n\t\t\ttooltip: \"Enabling this will test if any test introduces new properties on the `window` object. Stored as query-strings.\"\r\n\t\t},\r\n\t\t{\r\n\t\t\tid: \"notrycatch\",\r\n\t\t\tlabel: \"No try-catch\",\r\n\t\t\ttooltip: \"Enabling this will run tests outside of a try-catch block. Makes debugging exceptions in IE reasonable. Stored as query-strings.\"\r\n\t\t}\r\n\t],\r\n\r\n\t// Set of all modules.\r\n\tmodules: {},\r\n\r\n\t// logging callback queues\r\n\tbegin: [],\r\n\tdone: [],\r\n\tlog: [],\r\n\ttestStart: [],\r\n\ttestDone: [],\r\n\tmoduleStart: [],\r\n\tmoduleDone: []\r\n};\r\n\r\n// Initialize more QUnit.config and QUnit.urlParams\r\n(function() {\r\n\tvar i,\r\n\t\tlocation = window.location || { search: \"\", protocol: \"file:\" },\r\n\t\tparams = location.search.slice( 1 ).split( \"&\" ),\r\n\t\tlength = params.length,\r\n\t\turlParams = {},\r\n\t\tcurrent;\r\n\r\n\tif ( params[ 0 ] ) {\r\n\t\tfor ( i = 0; i < length; i++ ) {\r\n\t\t\tcurrent = params[ i ].split( \"=\" );\r\n\t\t\tcurrent[ 0 ] = decodeURIComponent( current[ 0 ] );\r\n\t\t\t// allow just a key to turn on a flag, e.g., test.html?noglobals\r\n\t\t\tcurrent[ 1 ] = current[ 1 ] ? decodeURIComponent( current[ 1 ] ) : true;\r\n\t\t\turlParams[ current[ 0 ] ] = current[ 1 ];\r\n\t\t}\r\n\t}\r\n\r\n\tQUnit.urlParams = urlParams;\r\n\r\n\t// String search anywhere in moduleName+testName\r\n\tconfig.filter = urlParams.filter;\r\n\r\n\t// Exact match of the module name\r\n\tconfig.module = urlParams.module;\r\n\r\n\tconfig.testNumber = parseInt( urlParams.testNumber, 10 ) || null;\r\n\r\n\t// Figure out if we're running the tests from a server or not\r\n\tQUnit.isLocal = location.protocol === \"file:\";\r\n}());\r\n\r\n// Export global variables, unless an 'exports' object exists,\r\n// in that case we assume we're in CommonJS (dealt with on the bottom of the script)\r\nif ( typeof exports === \"undefined\" ) {\r\n\textend( window, QUnit );\r\n\r\n\t// Expose QUnit object\r\n\twindow.QUnit = QUnit;\r\n}\r\n\r\n// Extend QUnit object,\r\n// these after set here because they should not be exposed as global functions\r\nextend( QUnit, {\r\n\tconfig: config,\r\n\r\n\t// Initialize the configuration options\r\n\tinit: function() {\r\n\t\textend( config, {\r\n\t\t\tstats: { all: 0, bad: 0 },\r\n\t\t\tmoduleStats: { all: 0, bad: 0 },\r\n\t\t\tstarted: +new Date(),\r\n\t\t\tupdateRate: 1000,\r\n\t\t\tblocking: false,\r\n\t\t\tautostart: true,\r\n\t\t\tautorun: false,\r\n\t\t\tfilter: \"\",\r\n\t\t\tqueue: [],\r\n\t\t\tsemaphore: 0\r\n\t\t});\r\n\r\n\t\tvar tests, banner, result,\r\n\t\t\tqunit = id( \"qunit\" );\r\n\r\n\t\tif ( qunit ) {\r\n\t\t\tqunit.innerHTML =\r\n\t\t\t\t\"<h1 id='qunit-header'>\" + escapeInnerText( document.title ) + \"</h1>\" +\r\n\t\t\t\t\"<h2 id='qunit-banner'></h2>\" +\r\n\t\t\t\t\"<div id='qunit-testrunner-toolbar'></div>\" +\r\n\t\t\t\t\"<h2 id='qunit-userAgent'></h2>\" +\r\n\t\t\t\t\"<ol id='qunit-tests'></ol>\";\r\n\t\t}\r\n\r\n\t\ttests = id( \"qunit-tests\" );\r\n\t\tbanner = id( \"qunit-banner\" );\r\n\t\tresult = id( \"qunit-testresult\" );\r\n\r\n\t\tif ( tests ) {\r\n\t\t\ttests.innerHTML = \"\";\r\n\t\t}\r\n\r\n\t\tif ( banner ) {\r\n\t\t\tbanner.className = \"\";\r\n\t\t}\r\n\r\n\t\tif ( result ) {\r\n\t\t\tresult.parentNode.removeChild( result );\r\n\t\t}\r\n\r\n\t\tif ( tests ) {\r\n\t\t\tresult = document.createElement( \"p\" );\r\n\t\t\tresult.id = \"qunit-testresult\";\r\n\t\t\tresult.className = \"result\";\r\n\t\t\ttests.parentNode.insertBefore( result, tests );\r\n\t\t\tresult.innerHTML = \"Running...<br/>&nbsp;\";\r\n\t\t}\r\n\t},\r\n\r\n\t// Resets the test setup. Useful for tests that modify the DOM.\r\n\treset: function() {\r\n\t\tvar fixture = id( \"qunit-fixture\" );\r\n\t\tif ( fixture ) {\r\n\t\t\tfixture.innerHTML = config.fixture;\r\n\t\t}\r\n\t},\r\n\r\n\t// Trigger an event on an element.\r\n\t// @example triggerEvent( document.body, \"click\" );\r\n\ttriggerEvent: function( elem, type, event ) {\r\n\t\tif ( document.createEvent ) {\r\n\t\t\tevent = document.createEvent( \"MouseEvents\" );\r\n\t\t\tevent.initMouseEvent(type, true, true, elem.ownerDocument.defaultView,\r\n\t\t\t\t0, 0, 0, 0, 0, false, false, false, false, 0, null);\r\n\r\n\t\t\telem.dispatchEvent( event );\r\n\t\t} else if ( elem.fireEvent ) {\r\n\t\t\telem.fireEvent( \"on\" + type );\r\n\t\t}\r\n\t},\r\n\r\n\t// Safe object type checking\r\n\tis: function( type, obj ) {\r\n\t\treturn QUnit.objectType( obj ) == type;\r\n\t},\r\n\r\n\tobjectType: function( obj ) {\r\n\t\tif ( typeof obj === \"undefined\" ) {\r\n\t\t\t\treturn \"undefined\";\r\n\t\t// consider: typeof null === object\r\n\t\t}\r\n\t\tif ( obj === null ) {\r\n\t\t\t\treturn \"null\";\r\n\t\t}\r\n\r\n\t\tvar type = toString.call( obj ).match(/^\\[object\\s(.*)\\]$/)[1] || \"\";\r\n\r\n\t\tswitch ( type ) {\r\n\t\t\tcase \"Number\":\r\n\t\t\t\tif ( isNaN(obj) ) {\r\n\t\t\t\t\treturn \"nan\";\r\n\t\t\t\t}\r\n\t\t\t\treturn \"number\";\r\n\t\t\tcase \"String\":\r\n\t\t\tcase \"Boolean\":\r\n\t\t\tcase \"Array\":\r\n\t\t\tcase \"Date\":\r\n\t\t\tcase \"RegExp\":\r\n\t\t\tcase \"Function\":\r\n\t\t\t\treturn type.toLowerCase();\r\n\t\t}\r\n\t\tif ( typeof obj === \"object\" ) {\r\n\t\t\treturn \"object\";\r\n\t\t}\r\n\t\treturn undefined;\r\n\t},\r\n\r\n\tpush: function( result, actual, expected, message ) {\r\n\t\tif ( !config.current ) {\r\n\t\t\tthrow new Error( \"assertion outside test context, was \" + sourceFromStacktrace() );\r\n\t\t}\r\n\r\n\t\tvar output, source,\r\n\t\t\tdetails = {\r\n\t\t\t\tmodule: config.current.module,\r\n\t\t\t\tname: config.current.testName,\r\n\t\t\t\tresult: result,\r\n\t\t\t\tmessage: message,\r\n\t\t\t\tactual: actual,\r\n\t\t\t\texpected: expected\r\n\t\t\t};\r\n\r\n\t\tmessage = escapeInnerText( message ) || ( result ? \"okay\" : \"failed\" );\r\n\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\r\n\t\toutput = message;\r\n\r\n\t\tif ( !result ) {\r\n\t\t\texpected = escapeInnerText( QUnit.jsDump.parse(expected) );\r\n\t\t\tactual = escapeInnerText( QUnit.jsDump.parse(actual) );\r\n\t\t\toutput += \"<table><tr class='test-expected'><th>Expected: </th><td><pre>\" + expected + \"</pre></td></tr>\";\r\n\r\n\t\t\tif ( actual != expected ) {\r\n\t\t\t\toutput += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + actual + \"</pre></td></tr>\";\r\n\t\t\t\toutput += \"<tr class='test-diff'><th>Diff: </th><td><pre>\" + QUnit.diff( expected, actual ) + \"</pre></td></tr>\";\r\n\t\t\t}\r\n\r\n\t\t\tsource = sourceFromStacktrace();\r\n\r\n\t\t\tif ( source ) {\r\n\t\t\t\tdetails.source = source;\r\n\t\t\t\toutput += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeInnerText( source ) + \"</pre></td></tr>\";\r\n\t\t\t}\r\n\r\n\t\t\toutput += \"</table>\";\r\n\t\t}\r\n\r\n\t\trunLoggingCallbacks( \"log\", QUnit, details );\r\n\r\n\t\tconfig.current.assertions.push({\r\n\t\t\tresult: !!result,\r\n\t\t\tmessage: output\r\n\t\t});\r\n\t},\r\n\r\n\tpushFailure: function( message, source, actual ) {\r\n\t\tif ( !config.current ) {\r\n\t\t\tthrow new Error( \"pushFailure() assertion outside test context, was \" + sourceFromStacktrace(2) );\r\n\t\t}\r\n\r\n\t\tvar output,\r\n\t\t\tdetails = {\r\n\t\t\t\tmodule: config.current.module,\r\n\t\t\t\tname: config.current.testName,\r\n\t\t\t\tresult: false,\r\n\t\t\t\tmessage: message\r\n\t\t\t};\r\n\r\n\t\tmessage = escapeInnerText( message ) || \"error\";\r\n\t\tmessage = \"<span class='test-message'>\" + message + \"</span>\";\r\n\t\toutput = message;\r\n\r\n\t\toutput += \"<table>\";\r\n\r\n\t\tif ( actual ) {\r\n\t\t\toutput += \"<tr class='test-actual'><th>Result: </th><td><pre>\" + escapeInnerText( actual ) + \"</pre></td></tr>\";\r\n\t\t}\r\n\r\n\t\tif ( source ) {\r\n\t\t\tdetails.source = source;\r\n\t\t\toutput += \"<tr class='test-source'><th>Source: </th><td><pre>\" + escapeInnerText( source ) + \"</pre></td></tr>\";\r\n\t\t}\r\n\r\n\t\toutput += \"</table>\";\r\n\r\n\t\trunLoggingCallbacks( \"log\", QUnit, details );\r\n\r\n\t\tconfig.current.assertions.push({\r\n\t\t\tresult: false,\r\n\t\t\tmessage: output\r\n\t\t});\r\n\t},\r\n\r\n\turl: function( params ) {\r\n\t\tparams = extend( extend( {}, QUnit.urlParams ), params );\r\n\t\tvar key,\r\n\t\t\tquerystring = \"?\";\r\n\r\n\t\tfor ( key in params ) {\r\n\t\t\tif ( !hasOwn.call( params, key ) ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tquerystring += encodeURIComponent( key ) + \"=\" +\r\n\t\t\t\tencodeURIComponent( params[ key ] ) + \"&\";\r\n\t\t}\r\n\t\treturn window.location.pathname + querystring.slice( 0, -1 );\r\n\t},\r\n\r\n\textend: extend,\r\n\tid: id,\r\n\taddEvent: addEvent\r\n\t// load, equiv, jsDump, diff: Attached later\r\n});\r\n\r\n/**\r\n * @deprecated: Created for backwards compatibility with test runner that set the hook function\r\n * into QUnit.{hook}, instead of invoking it and passing the hook function.\r\n * QUnit.constructor is set to the empty F() above so that we can add to it's prototype here.\r\n * Doing this allows us to tell if the following methods have been overwritten on the actual\r\n * QUnit object.\r\n */\r\nextend( QUnit.constructor.prototype, {\r\n\r\n\t// Logging callbacks; all receive a single argument with the listed properties\r\n\t// run test/logs.html for any related changes\r\n\tbegin: registerLoggingCallback( \"begin\" ),\r\n\r\n\t// done: { failed, passed, total, runtime }\r\n\tdone: registerLoggingCallback( \"done\" ),\r\n\r\n\t// log: { result, actual, expected, message }\r\n\tlog: registerLoggingCallback( \"log\" ),\r\n\r\n\t// testStart: { name }\r\n\ttestStart: registerLoggingCallback( \"testStart\" ),\r\n\r\n\t// testDone: { name, failed, passed, total }\r\n\ttestDone: registerLoggingCallback( \"testDone\" ),\r\n\r\n\t// moduleStart: { name }\r\n\tmoduleStart: registerLoggingCallback( \"moduleStart\" ),\r\n\r\n\t// moduleDone: { name, failed, passed, total }\r\n\tmoduleDone: registerLoggingCallback( \"moduleDone\" )\r\n});\r\n\r\nif ( typeof document === \"undefined\" || document.readyState === \"complete\" ) {\r\n\tconfig.autorun = true;\r\n}\r\n\r\nQUnit.load = function() {\r\n\trunLoggingCallbacks( \"begin\", QUnit, {} );\r\n\r\n\t// Initialize the config, saving the execution queue\r\n\tvar banner, filter, i, label, len, main, ol, toolbar, userAgent, val, urlConfigCheckboxes, moduleFilter,\r\n\t    numModules = 0,\r\n\t    moduleFilterHtml = \"\",\r\n\t\turlConfigHtml = \"\",\r\n\t\toldconfig = extend( {}, config );\r\n\r\n\tQUnit.init();\r\n\textend(config, oldconfig);\r\n\r\n\tconfig.blocking = false;\r\n\r\n\tlen = config.urlConfig.length;\r\n\r\n\tfor ( i = 0; i < len; i++ ) {\r\n\t\tval = config.urlConfig[i];\r\n\t\tif ( typeof val === \"string\" ) {\r\n\t\t\tval = {\r\n\t\t\t\tid: val,\r\n\t\t\t\tlabel: val,\r\n\t\t\t\ttooltip: \"[no tooltip available]\"\r\n\t\t\t};\r\n\t\t}\r\n\t\tconfig[ val.id ] = QUnit.urlParams[ val.id ];\r\n\t\turlConfigHtml += \"<input id='qunit-urlconfig-\" + val.id + \"' name='\" + val.id + \"' type='checkbox'\" + ( config[ val.id ] ? \" checked='checked'\" : \"\" ) + \" title='\" + val.tooltip + \"'><label for='qunit-urlconfig-\" + val.id + \"' title='\" + val.tooltip + \"'>\" + val.label + \"</label>\";\r\n\t}\r\n\r\n\tmoduleFilterHtml += \"<label for='qunit-modulefilter'>Module: </label><select id='qunit-modulefilter' name='modulefilter'><option value='' \" + ( config.module === undefined  ? \"selected\" : \"\" ) + \">< All Modules ></option>\";\r\n\tfor ( i in config.modules ) {\r\n\t\tif ( config.modules.hasOwnProperty( i ) ) {\r\n\t\t\tnumModules += 1;\r\n\t\t\tmoduleFilterHtml += \"<option value='\" + encodeURIComponent(i) + \"' \" + ( config.module === i ? \"selected\" : \"\" ) + \">\" + i + \"</option>\";\r\n\t\t}\r\n\t}\r\n\tmoduleFilterHtml += \"</select>\";\r\n\r\n\t// `userAgent` initialized at top of scope\r\n\tuserAgent = id( \"qunit-userAgent\" );\r\n\tif ( userAgent ) {\r\n\t\tuserAgent.innerHTML = navigator.userAgent;\r\n\t}\r\n\r\n\t// `banner` initialized at top of scope\r\n\tbanner = id( \"qunit-header\" );\r\n\tif ( banner ) {\r\n\t\tbanner.innerHTML = \"<a href='\" + QUnit.url({ filter: undefined, module: undefined, testNumber: undefined }) + \"'>\" + banner.innerHTML + \"</a> \";\r\n\t}\r\n\r\n\t// `toolbar` initialized at top of scope\r\n\ttoolbar = id( \"qunit-testrunner-toolbar\" );\r\n\tif ( toolbar ) {\r\n\t\t// `filter` initialized at top of scope\r\n\t\tfilter = document.createElement( \"input\" );\r\n\t\tfilter.type = \"checkbox\";\r\n\t\tfilter.id = \"qunit-filter-pass\";\r\n\r\n\t\taddEvent( filter, \"click\", function() {\r\n\t\t\tvar tmp,\r\n\t\t\t\tol = document.getElementById( \"qunit-tests\" );\r\n\r\n\t\t\tif ( filter.checked ) {\r\n\t\t\t\tol.className = ol.className + \" hidepass\";\r\n\t\t\t} else {\r\n\t\t\t\ttmp = \" \" + ol.className.replace( /[\\n\\t\\r]/g, \" \" ) + \" \";\r\n\t\t\t\tol.className = tmp.replace( / hidepass /, \" \" );\r\n\t\t\t}\r\n\t\t\tif ( defined.sessionStorage ) {\r\n\t\t\t\tif (filter.checked) {\r\n\t\t\t\t\tsessionStorage.setItem( \"qunit-filter-passed-tests\", \"true\" );\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsessionStorage.removeItem( \"qunit-filter-passed-tests\" );\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif ( config.hidepassed || defined.sessionStorage && sessionStorage.getItem( \"qunit-filter-passed-tests\" ) ) {\r\n\t\t\tfilter.checked = true;\r\n\t\t\t// `ol` initialized at top of scope\r\n\t\t\tol = document.getElementById( \"qunit-tests\" );\r\n\t\t\tol.className = ol.className + \" hidepass\";\r\n\t\t}\r\n\t\ttoolbar.appendChild( filter );\r\n\r\n\t\t// `label` initialized at top of scope\r\n\t\tlabel = document.createElement( \"label\" );\r\n\t\tlabel.setAttribute( \"for\", \"qunit-filter-pass\" );\r\n\t\tlabel.setAttribute( \"title\", \"Only show tests and assertons that fail. Stored in sessionStorage.\" );\r\n\t\tlabel.innerHTML = \"Hide passed tests\";\r\n\t\ttoolbar.appendChild( label );\r\n\r\n\t\turlConfigCheckboxes = document.createElement( 'span' );\r\n\t\turlConfigCheckboxes.innerHTML = urlConfigHtml;\r\n\t\taddEvent( urlConfigCheckboxes, \"change\", function( event ) {\r\n\t\t\tvar params = {};\r\n\t\t\tparams[ event.target.name ] = event.target.checked ? true : undefined;\r\n\t\t\twindow.location = QUnit.url( params );\r\n\t\t});\r\n\t\ttoolbar.appendChild( urlConfigCheckboxes );\r\n\r\n\t\tif (numModules > 1) {\r\n\t\t\tmoduleFilter = document.createElement( 'span' );\r\n\t\t\tmoduleFilter.setAttribute( 'id', 'qunit-modulefilter-container' );\r\n\t\t\tmoduleFilter.innerHTML = moduleFilterHtml;\r\n\t\t\taddEvent( moduleFilter, \"change\", function() {\r\n\t\t\t\tvar selectBox = moduleFilter.getElementsByTagName(\"select\")[0],\r\n\t\t\t\t    selectedModule = decodeURIComponent(selectBox.options[selectBox.selectedIndex].value);\r\n\r\n\t\t\t\twindow.location = QUnit.url( { module: ( selectedModule === \"\" ) ? undefined : selectedModule } );\r\n\t\t\t});\r\n\t\t\ttoolbar.appendChild(moduleFilter);\r\n\t\t}\r\n\t}\r\n\r\n\t// `main` initialized at top of scope\r\n\tmain = id( \"qunit-fixture\" );\r\n\tif ( main ) {\r\n\t\tconfig.fixture = main.innerHTML;\r\n\t}\r\n\r\n\tif ( config.autostart ) {\r\n\t\tQUnit.start();\r\n\t}\r\n};\r\n\r\naddEvent( window, \"load\", QUnit.load );\r\n\r\n// `onErrorFnPrev` initialized at top of scope\r\n// Preserve other handlers\r\nonErrorFnPrev = window.onerror;\r\n\r\n// Cover uncaught exceptions\r\n// Returning true will surpress the default browser handler,\r\n// returning false will let it run.\r\nwindow.onerror = function ( error, filePath, linerNr ) {\r\n\tvar ret = false;\r\n\tif ( onErrorFnPrev ) {\r\n\t\tret = onErrorFnPrev( error, filePath, linerNr );\r\n\t}\r\n\r\n\t// Treat return value as window.onerror itself does,\r\n\t// Only do our handling if not surpressed.\r\n\tif ( ret !== true ) {\r\n\t\tif ( QUnit.config.current ) {\r\n\t\t\tif ( QUnit.config.current.ignoreGlobalErrors ) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\r\n\t\t} else {\r\n\t\t\tQUnit.test( \"global failure\", extend( function() {\r\n\t\t\t\tQUnit.pushFailure( error, filePath + \":\" + linerNr );\r\n\t\t\t}, { validTest: validTest } ) );\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\treturn ret;\r\n};\r\n\r\nfunction done() {\r\n\tconfig.autorun = true;\r\n\r\n\t// Log the last module results\r\n\tif ( config.currentModule ) {\r\n\t\trunLoggingCallbacks( \"moduleDone\", QUnit, {\r\n\t\t\tname: config.currentModule,\r\n\t\t\tfailed: config.moduleStats.bad,\r\n\t\t\tpassed: config.moduleStats.all - config.moduleStats.bad,\r\n\t\t\ttotal: config.moduleStats.all\r\n\t\t});\r\n\t}\r\n\r\n\tvar i, key,\r\n\t\tbanner = id( \"qunit-banner\" ),\r\n\t\ttests = id( \"qunit-tests\" ),\r\n\t\truntime = +new Date() - config.started,\r\n\t\tpassed = config.stats.all - config.stats.bad,\r\n\t\thtml = [\r\n\t\t\t\"Tests completed in \",\r\n\t\t\truntime,\r\n\t\t\t\" milliseconds.<br/>\",\r\n\t\t\t\"<span class='passed'>\",\r\n\t\t\tpassed,\r\n\t\t\t\"</span> tests of <span class='total'>\",\r\n\t\t\tconfig.stats.all,\r\n\t\t\t\"</span> passed, <span class='failed'>\",\r\n\t\t\tconfig.stats.bad,\r\n\t\t\t\"</span> failed.\"\r\n\t\t].join( \"\" );\r\n\r\n\tif ( banner ) {\r\n\t\tbanner.className = ( config.stats.bad ? \"qunit-fail\" : \"qunit-pass\" );\r\n\t}\r\n\r\n\tif ( tests ) {\r\n\t\tid( \"qunit-testresult\" ).innerHTML = html;\r\n\t}\r\n\r\n\tif ( config.altertitle && typeof document !== \"undefined\" && document.title ) {\r\n\t\t// show ✖ for good, ✔ for bad suite result in title\r\n\t\t// use escape sequences in case file gets loaded with non-utf-8-charset\r\n\t\tdocument.title = [\r\n\t\t\t( config.stats.bad ? \"\\u2716\" : \"\\u2714\" ),\r\n\t\t\tdocument.title.replace( /^[\\u2714\\u2716] /i, \"\" )\r\n\t\t].join( \" \" );\r\n\t}\r\n\r\n\t// clear own sessionStorage items if all tests passed\r\n\tif ( config.reorder && defined.sessionStorage && config.stats.bad === 0 ) {\r\n\t\t// `key` & `i` initialized at top of scope\r\n\t\tfor ( i = 0; i < sessionStorage.length; i++ ) {\r\n\t\t\tkey = sessionStorage.key( i++ );\r\n\t\t\tif ( key.indexOf( \"qunit-test-\" ) === 0 ) {\r\n\t\t\t\tsessionStorage.removeItem( key );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// scroll back to top to show results\r\n\tif ( window.scrollTo ) {\r\n\t\twindow.scrollTo(0, 0);\r\n\t}\r\n\r\n\trunLoggingCallbacks( \"done\", QUnit, {\r\n\t\tfailed: config.stats.bad,\r\n\t\tpassed: passed,\r\n\t\ttotal: config.stats.all,\r\n\t\truntime: runtime\r\n\t});\r\n}\r\n\r\n/** @return Boolean: true if this test should be ran */\r\nfunction validTest( test ) {\r\n\tvar include,\r\n\t\tfilter = config.filter && config.filter.toLowerCase(),\r\n\t\tmodule = config.module && config.module.toLowerCase(),\r\n\t\tfullName = (test.module + \": \" + test.testName).toLowerCase();\r\n\r\n\t// Internally-generated tests are always valid\r\n\tif ( test.callback && test.callback.validTest === validTest ) {\r\n\t\tdelete test.callback.validTest;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tif ( config.testNumber ) {\r\n\t\treturn test.testNumber === config.testNumber;\r\n\t}\r\n\r\n\tif ( module && ( !test.module || test.module.toLowerCase() !== module ) ) {\r\n\t\treturn false;\r\n\t}\r\n\r\n\tif ( !filter ) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\tinclude = filter.charAt( 0 ) !== \"!\";\r\n\tif ( !include ) {\r\n\t\tfilter = filter.slice( 1 );\r\n\t}\r\n\r\n\t// If the filter matches, we need to honour include\r\n\tif ( fullName.indexOf( filter ) !== -1 ) {\r\n\t\treturn include;\r\n\t}\r\n\r\n\t// Otherwise, do the opposite\r\n\treturn !include;\r\n}\r\n\r\n// so far supports only Firefox, Chrome and Opera (buggy), Safari (for real exceptions)\r\n// Later Safari and IE10 are supposed to support error.stack as well\r\n// See also https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error/Stack\r\nfunction extractStacktrace( e, offset ) {\r\n\toffset = offset === undefined ? 3 : offset;\r\n\r\n\tvar stack, include, i, regex;\r\n\r\n\tif ( e.stacktrace ) {\r\n\t\t// Opera\r\n\t\treturn e.stacktrace.split( \"\\n\" )[ offset + 3 ];\r\n\t} else if ( e.stack ) {\r\n\t\t// Firefox, Chrome\r\n\t\tstack = e.stack.split( \"\\n\" );\r\n\t\tif (/^error$/i.test( stack[0] ) ) {\r\n\t\t\tstack.shift();\r\n\t\t}\r\n\t\tif ( fileName ) {\r\n\t\t\tinclude = [];\r\n\t\t\tfor ( i = offset; i < stack.length; i++ ) {\r\n\t\t\t\tif ( stack[ i ].indexOf( fileName ) != -1 ) {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tinclude.push( stack[ i ] );\r\n\t\t\t}\r\n\t\t\tif ( include.length ) {\r\n\t\t\t\treturn include.join( \"\\n\" );\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn stack[ offset ];\r\n\t} else if ( e.sourceURL ) {\r\n\t\t// Safari, PhantomJS\r\n\t\t// hopefully one day Safari provides actual stacktraces\r\n\t\t// exclude useless self-reference for generated Error objects\r\n\t\tif ( /qunit.js$/.test( e.sourceURL ) ) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// for actual exceptions, this is useful\r\n\t\treturn e.sourceURL + \":\" + e.line;\r\n\t}\r\n}\r\nfunction sourceFromStacktrace( offset ) {\r\n\ttry {\r\n\t\tthrow new Error();\r\n\t} catch ( e ) {\r\n\t\treturn extractStacktrace( e, offset );\r\n\t}\r\n}\r\n\r\nfunction escapeInnerText( s ) {\r\n\tif ( !s ) {\r\n\t\treturn \"\";\r\n\t}\r\n\ts = s + \"\";\r\n\treturn s.replace( /[\\&<>]/g, function( s ) {\r\n\t\tswitch( s ) {\r\n\t\t\tcase \"&\": return \"&amp;\";\r\n\t\t\tcase \"<\": return \"&lt;\";\r\n\t\t\tcase \">\": return \"&gt;\";\r\n\t\t\tdefault: return s;\r\n\t\t}\r\n\t});\r\n}\r\n\r\nfunction synchronize( callback, last ) {\r\n\tconfig.queue.push( callback );\r\n\r\n\tif ( config.autorun && !config.blocking ) {\r\n\t\tprocess( last );\r\n\t}\r\n}\r\n\r\nfunction process( last ) {\r\n\tfunction next() {\r\n\t\tprocess( last );\r\n\t}\r\n\tvar start = new Date().getTime();\r\n\tconfig.depth = config.depth ? config.depth + 1 : 1;\r\n\r\n\twhile ( config.queue.length && !config.blocking ) {\r\n\t\tif ( !defined.setTimeout || config.updateRate <= 0 || ( ( new Date().getTime() - start ) < config.updateRate ) ) {\r\n\t\t\tconfig.queue.shift()();\r\n\t\t} else {\r\n\t\t\twindow.setTimeout( next, 13 );\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tconfig.depth--;\r\n\tif ( last && !config.blocking && !config.queue.length && config.depth === 0 ) {\r\n\t\tdone();\r\n\t}\r\n}\r\n\r\nfunction saveGlobal() {\r\n\tconfig.pollution = [];\r\n\r\n\tif ( config.noglobals ) {\r\n\t\tfor ( var key in window ) {\r\n\t\t\t// in Opera sometimes DOM element ids show up here, ignore them\r\n\t\t\tif ( !hasOwn.call( window, key ) || /^qunit-test-output/.test( key ) ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tconfig.pollution.push( key );\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction checkPollution( name ) {\r\n\tvar newGlobals,\r\n\t\tdeletedGlobals,\r\n\t\told = config.pollution;\r\n\r\n\tsaveGlobal();\r\n\r\n\tnewGlobals = diff( config.pollution, old );\r\n\tif ( newGlobals.length > 0 ) {\r\n\t\tQUnit.pushFailure( \"Introduced global variable(s): \" + newGlobals.join(\", \") );\r\n\t}\r\n\r\n\tdeletedGlobals = diff( old, config.pollution );\r\n\tif ( deletedGlobals.length > 0 ) {\r\n\t\tQUnit.pushFailure( \"Deleted global variable(s): \" + deletedGlobals.join(\", \") );\r\n\t}\r\n}\r\n\r\n// returns a new Array with the elements that are in a but not in b\r\nfunction diff( a, b ) {\r\n\tvar i, j,\r\n\t\tresult = a.slice();\r\n\r\n\tfor ( i = 0; i < result.length; i++ ) {\r\n\t\tfor ( j = 0; j < b.length; j++ ) {\r\n\t\t\tif ( result[i] === b[j] ) {\r\n\t\t\t\tresult.splice( i, 1 );\r\n\t\t\t\ti--;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\nfunction extend( a, b ) {\r\n\tfor ( var prop in b ) {\r\n\t\tif ( b[ prop ] === undefined ) {\r\n\t\t\tdelete a[ prop ];\r\n\r\n\t\t// Avoid \"Member not found\" error in IE8 caused by setting window.constructor\r\n\t\t} else if ( prop !== \"constructor\" || a !== window ) {\r\n\t\t\ta[ prop ] = b[ prop ];\r\n\t\t}\r\n\t}\r\n\r\n\treturn a;\r\n}\r\n\r\nfunction addEvent( elem, type, fn ) {\r\n\tif ( elem.addEventListener ) {\r\n\t\telem.addEventListener( type, fn, false );\r\n\t} else if ( elem.attachEvent ) {\r\n\t\telem.attachEvent( \"on\" + type, fn );\r\n\t} else {\r\n\t\tfn();\r\n\t}\r\n}\r\n\r\nfunction id( name ) {\r\n\treturn !!( typeof document !== \"undefined\" && document && document.getElementById ) &&\r\n\t\tdocument.getElementById( name );\r\n}\r\n\r\nfunction registerLoggingCallback( key ) {\r\n\treturn function( callback ) {\r\n\t\tconfig[key].push( callback );\r\n\t};\r\n}\r\n\r\n// Supports deprecated method of completely overwriting logging callbacks\r\nfunction runLoggingCallbacks( key, scope, args ) {\r\n\t//debugger;\r\n\tvar i, callbacks;\r\n\tif ( QUnit.hasOwnProperty( key ) ) {\r\n\t\tQUnit[ key ].call(scope, args );\r\n\t} else {\r\n\t\tcallbacks = config[ key ];\r\n\t\tfor ( i = 0; i < callbacks.length; i++ ) {\r\n\t\t\tcallbacks[ i ].call( scope, args );\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// Test for equality any JavaScript type.\r\n// Author: Philippe Rathé <prathe@gmail.com>\r\nQUnit.equiv = (function() {\r\n\r\n\t// Call the o related callback with the given arguments.\r\n\tfunction bindCallbacks( o, callbacks, args ) {\r\n\t\tvar prop = QUnit.objectType( o );\r\n\t\tif ( prop ) {\r\n\t\t\tif ( QUnit.objectType( callbacks[ prop ] ) === \"function\" ) {\r\n\t\t\t\treturn callbacks[ prop ].apply( callbacks, args );\r\n\t\t\t} else {\r\n\t\t\t\treturn callbacks[ prop ]; // or undefined\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// the real equiv function\r\n\tvar innerEquiv,\r\n\t\t// stack to decide between skip/abort functions\r\n\t\tcallers = [],\r\n\t\t// stack to avoiding loops from circular referencing\r\n\t\tparents = [],\r\n\r\n\t\tgetProto = Object.getPrototypeOf || function ( obj ) {\r\n\t\t\treturn obj.__proto__;\r\n\t\t},\r\n\t\tcallbacks = (function () {\r\n\r\n\t\t\t// for string, boolean, number and null\r\n\t\t\tfunction useStrictEquality( b, a ) {\r\n\t\t\t\tif ( b instanceof a.constructor || a instanceof b.constructor ) {\r\n\t\t\t\t\t// to catch short annotaion VS 'new' annotation of a\r\n\t\t\t\t\t// declaration\r\n\t\t\t\t\t// e.g. var i = 1;\r\n\t\t\t\t\t// var j = new Number(1);\r\n\t\t\t\t\treturn a == b;\r\n\t\t\t\t} else {\r\n\t\t\t\t\treturn a === b;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn {\r\n\t\t\t\t\"string\": useStrictEquality,\r\n\t\t\t\t\"boolean\": useStrictEquality,\r\n\t\t\t\t\"number\": useStrictEquality,\r\n\t\t\t\t\"null\": useStrictEquality,\r\n\t\t\t\t\"undefined\": useStrictEquality,\r\n\r\n\t\t\t\t\"nan\": function( b ) {\r\n\t\t\t\t\treturn isNaN( b );\r\n\t\t\t\t},\r\n\r\n\t\t\t\t\"date\": function( b, a ) {\r\n\t\t\t\t\treturn QUnit.objectType( b ) === \"date\" && a.valueOf() === b.valueOf();\r\n\t\t\t\t},\r\n\r\n\t\t\t\t\"regexp\": function( b, a ) {\r\n\t\t\t\t\treturn QUnit.objectType( b ) === \"regexp\" &&\r\n\t\t\t\t\t\t// the regex itself\r\n\t\t\t\t\t\ta.source === b.source &&\r\n\t\t\t\t\t\t// and its modifers\r\n\t\t\t\t\t\ta.global === b.global &&\r\n\t\t\t\t\t\t// (gmi) ...\r\n\t\t\t\t\t\ta.ignoreCase === b.ignoreCase &&\r\n\t\t\t\t\t\ta.multiline === b.multiline &&\r\n\t\t\t\t\t\ta.sticky === b.sticky;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t// - skip when the property is a method of an instance (OOP)\r\n\t\t\t\t// - abort otherwise,\r\n\t\t\t\t// initial === would have catch identical references anyway\r\n\t\t\t\t\"function\": function() {\r\n\t\t\t\t\tvar caller = callers[callers.length - 1];\r\n\t\t\t\t\treturn caller !== Object && typeof caller !== \"undefined\";\r\n\t\t\t\t},\r\n\r\n\t\t\t\t\"array\": function( b, a ) {\r\n\t\t\t\t\tvar i, j, len, loop;\r\n\r\n\t\t\t\t\t// b could be an object literal here\r\n\t\t\t\t\tif ( QUnit.objectType( b ) !== \"array\" ) {\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlen = a.length;\r\n\t\t\t\t\tif ( len !== b.length ) {\r\n\t\t\t\t\t\t// safe and faster\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// track reference to avoid circular references\r\n\t\t\t\t\tparents.push( a );\r\n\t\t\t\t\tfor ( i = 0; i < len; i++ ) {\r\n\t\t\t\t\t\tloop = false;\r\n\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\r\n\t\t\t\t\t\t\tif ( parents[j] === a[i] ) {\r\n\t\t\t\t\t\t\t\tloop = true;// dont rewalk array\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( !loop && !innerEquiv(a[i], b[i]) ) {\r\n\t\t\t\t\t\t\tparents.pop();\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tparents.pop();\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t},\r\n\r\n\t\t\t\t\"object\": function( b, a ) {\r\n\t\t\t\t\tvar i, j, loop,\r\n\t\t\t\t\t\t// Default to true\r\n\t\t\t\t\t\teq = true,\r\n\t\t\t\t\t\taProperties = [],\r\n\t\t\t\t\t\tbProperties = [];\r\n\r\n\t\t\t\t\t// comparing constructors is more strict than using\r\n\t\t\t\t\t// instanceof\r\n\t\t\t\t\tif ( a.constructor !== b.constructor ) {\r\n\t\t\t\t\t\t// Allow objects with no prototype to be equivalent to\r\n\t\t\t\t\t\t// objects with Object as their constructor.\r\n\t\t\t\t\t\tif ( !(( getProto(a) === null && getProto(b) === Object.prototype ) ||\r\n\t\t\t\t\t\t\t( getProto(b) === null && getProto(a) === Object.prototype ) ) ) {\r\n\t\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// stack constructor before traversing properties\r\n\t\t\t\t\tcallers.push( a.constructor );\r\n\t\t\t\t\t// track reference to avoid circular references\r\n\t\t\t\t\tparents.push( a );\r\n\r\n\t\t\t\t\tfor ( i in a ) { // be strict: don't ensures hasOwnProperty\r\n\t\t\t\t\t\t\t\t\t// and go deep\r\n\t\t\t\t\t\tloop = false;\r\n\t\t\t\t\t\tfor ( j = 0; j < parents.length; j++ ) {\r\n\t\t\t\t\t\t\tif ( parents[j] === a[i] ) {\r\n\t\t\t\t\t\t\t\t// don't go down the same path twice\r\n\t\t\t\t\t\t\t\tloop = true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\taProperties.push(i); // collect a's properties\r\n\r\n\t\t\t\t\t\tif (!loop && !innerEquiv( a[i], b[i] ) ) {\r\n\t\t\t\t\t\t\teq = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcallers.pop(); // unstack, we are done\r\n\t\t\t\t\tparents.pop();\r\n\r\n\t\t\t\t\tfor ( i in b ) {\r\n\t\t\t\t\t\tbProperties.push( i ); // collect b's properties\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Ensures identical properties name\r\n\t\t\t\t\treturn eq && innerEquiv( aProperties.sort(), bProperties.sort() );\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t}());\r\n\r\n\tinnerEquiv = function() { // can take multiple arguments\r\n\t\tvar args = [].slice.apply( arguments );\r\n\t\tif ( args.length < 2 ) {\r\n\t\t\treturn true; // end transition\r\n\t\t}\r\n\r\n\t\treturn (function( a, b ) {\r\n\t\t\tif ( a === b ) {\r\n\t\t\t\treturn true; // catch the most you can\r\n\t\t\t} else if ( a === null || b === null || typeof a === \"undefined\" ||\r\n\t\t\t\t\ttypeof b === \"undefined\" ||\r\n\t\t\t\t\tQUnit.objectType(a) !== QUnit.objectType(b) ) {\r\n\t\t\t\treturn false; // don't lose time with error prone cases\r\n\t\t\t} else {\r\n\t\t\t\treturn bindCallbacks(a, callbacks, [ b, a ]);\r\n\t\t\t}\r\n\r\n\t\t\t// apply transition with (1..n) arguments\r\n\t\t}( args[0], args[1] ) && arguments.callee.apply( this, args.splice(1, args.length - 1 )) );\r\n\t};\r\n\r\n\treturn innerEquiv;\r\n}());\r\n\r\n/**\r\n * jsDump Copyright (c) 2008 Ariel Flesler - aflesler(at)gmail(dot)com |\r\n * http://flesler.blogspot.com Licensed under BSD\r\n * (http://www.opensource.org/licenses/bsd-license.php) Date: 5/15/2008\r\n *\r\n * @projectDescription Advanced and extensible data dumping for Javascript.\r\n * @version 1.0.0\r\n * @author Ariel Flesler\r\n * @link {http://flesler.blogspot.com/2008/05/jsdump-pretty-dump-of-any-javascript.html}\r\n */\r\nQUnit.jsDump = (function() {\r\n\tfunction quote( str ) {\r\n\t\treturn '\"' + str.toString().replace( /\"/g, '\\\\\"' ) + '\"';\r\n\t}\r\n\tfunction literal( o ) {\r\n\t\treturn o + \"\";\r\n\t}\r\n\tfunction join( pre, arr, post ) {\r\n\t\tvar s = jsDump.separator(),\r\n\t\t\tbase = jsDump.indent(),\r\n\t\t\tinner = jsDump.indent(1);\r\n\t\tif ( arr.join ) {\r\n\t\t\tarr = arr.join( \",\" + s + inner );\r\n\t\t}\r\n\t\tif ( !arr ) {\r\n\t\t\treturn pre + post;\r\n\t\t}\r\n\t\treturn [ pre, inner + arr, base + post ].join(s);\r\n\t}\r\n\tfunction array( arr, stack ) {\r\n\t\tvar i = arr.length, ret = new Array(i);\r\n\t\tthis.up();\r\n\t\twhile ( i-- ) {\r\n\t\t\tret[i] = this.parse( arr[i] , undefined , stack);\r\n\t\t}\r\n\t\tthis.down();\r\n\t\treturn join( \"[\", ret, \"]\" );\r\n\t}\r\n\r\n\tvar reName = /^function (\\w+)/,\r\n\t\tjsDump = {\r\n\t\t\tparse: function( obj, type, stack ) { //type is used mostly internally, you can fix a (custom)type in advance\r\n\t\t\t\tstack = stack || [ ];\r\n\t\t\t\tvar inStack, res,\r\n\t\t\t\t\tparser = this.parsers[ type || this.typeOf(obj) ];\r\n\r\n\t\t\t\ttype = typeof parser;\r\n\t\t\t\tinStack = inArray( obj, stack );\r\n\r\n\t\t\t\tif ( inStack != -1 ) {\r\n\t\t\t\t\treturn \"recursion(\" + (inStack - stack.length) + \")\";\r\n\t\t\t\t}\r\n\t\t\t\t//else\r\n\t\t\t\tif ( type == \"function\" )  {\r\n\t\t\t\t\tstack.push( obj );\r\n\t\t\t\t\tres = parser.call( this, obj, stack );\r\n\t\t\t\t\tstack.pop();\r\n\t\t\t\t\treturn res;\r\n\t\t\t\t}\r\n\t\t\t\t// else\r\n\t\t\t\treturn ( type == \"string\" ) ? parser : this.parsers.error;\r\n\t\t\t},\r\n\t\t\ttypeOf: function( obj ) {\r\n\t\t\t\tvar type;\r\n\t\t\t\tif ( obj === null ) {\r\n\t\t\t\t\ttype = \"null\";\r\n\t\t\t\t} else if ( typeof obj === \"undefined\" ) {\r\n\t\t\t\t\ttype = \"undefined\";\r\n\t\t\t\t} else if ( QUnit.is( \"regexp\", obj) ) {\r\n\t\t\t\t\ttype = \"regexp\";\r\n\t\t\t\t} else if ( QUnit.is( \"date\", obj) ) {\r\n\t\t\t\t\ttype = \"date\";\r\n\t\t\t\t} else if ( QUnit.is( \"function\", obj) ) {\r\n\t\t\t\t\ttype = \"function\";\r\n\t\t\t\t} else if ( typeof obj.setInterval !== undefined && typeof obj.document !== \"undefined\" && typeof obj.nodeType === \"undefined\" ) {\r\n\t\t\t\t\ttype = \"window\";\r\n\t\t\t\t} else if ( obj.nodeType === 9 ) {\r\n\t\t\t\t\ttype = \"document\";\r\n\t\t\t\t} else if ( obj.nodeType ) {\r\n\t\t\t\t\ttype = \"node\";\r\n\t\t\t\t} else if (\r\n\t\t\t\t\t// native arrays\r\n\t\t\t\t\ttoString.call( obj ) === \"[object Array]\" ||\r\n\t\t\t\t\t// NodeList objects\r\n\t\t\t\t\t( typeof obj.length === \"number\" && typeof obj.item !== \"undefined\" && ( obj.length ? obj.item(0) === obj[0] : ( obj.item( 0 ) === null && typeof obj[0] === \"undefined\" ) ) )\r\n\t\t\t\t) {\r\n\t\t\t\t\ttype = \"array\";\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = typeof obj;\r\n\t\t\t\t}\r\n\t\t\t\treturn type;\r\n\t\t\t},\r\n\t\t\tseparator: function() {\r\n\t\t\t\treturn this.multiline ?\tthis.HTML ? \"<br />\" : \"\\n\" : this.HTML ? \"&nbsp;\" : \" \";\r\n\t\t\t},\r\n\t\t\tindent: function( extra ) {// extra can be a number, shortcut for increasing-calling-decreasing\r\n\t\t\t\tif ( !this.multiline ) {\r\n\t\t\t\t\treturn \"\";\r\n\t\t\t\t}\r\n\t\t\t\tvar chr = this.indentChar;\r\n\t\t\t\tif ( this.HTML ) {\r\n\t\t\t\t\tchr = chr.replace( /\\t/g, \"   \" ).replace( / /g, \"&nbsp;\" );\r\n\t\t\t\t}\r\n\t\t\t\treturn new Array( this._depth_ + (extra||0) ).join(chr);\r\n\t\t\t},\r\n\t\t\tup: function( a ) {\r\n\t\t\t\tthis._depth_ += a || 1;\r\n\t\t\t},\r\n\t\t\tdown: function( a ) {\r\n\t\t\t\tthis._depth_ -= a || 1;\r\n\t\t\t},\r\n\t\t\tsetParser: function( name, parser ) {\r\n\t\t\t\tthis.parsers[name] = parser;\r\n\t\t\t},\r\n\t\t\t// The next 3 are exposed so you can use them\r\n\t\t\tquote: quote,\r\n\t\t\tliteral: literal,\r\n\t\t\tjoin: join,\r\n\t\t\t//\r\n\t\t\t_depth_: 1,\r\n\t\t\t// This is the list of parsers, to modify them, use jsDump.setParser\r\n\t\t\tparsers: {\r\n\t\t\t\twindow: \"[Window]\",\r\n\t\t\t\tdocument: \"[Document]\",\r\n\t\t\t\terror: \"[ERROR]\", //when no parser is found, shouldn\"t happen\r\n\t\t\t\tunknown: \"[Unknown]\",\r\n\t\t\t\t\"null\": \"null\",\r\n\t\t\t\t\"undefined\": \"undefined\",\r\n\t\t\t\t\"function\": function( fn ) {\r\n\t\t\t\t\tvar ret = \"function\",\r\n\t\t\t\t\t\tname = \"name\" in fn ? fn.name : (reName.exec(fn) || [])[1];//functions never have name in IE\r\n\r\n\t\t\t\t\tif ( name ) {\r\n\t\t\t\t\t\tret += \" \" + name;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tret += \"( \";\r\n\r\n\t\t\t\t\tret = [ ret, QUnit.jsDump.parse( fn, \"functionArgs\" ), \"){\" ].join( \"\" );\r\n\t\t\t\t\treturn join( ret, QUnit.jsDump.parse(fn,\"functionCode\" ), \"}\" );\r\n\t\t\t\t},\r\n\t\t\t\tarray: array,\r\n\t\t\t\tnodelist: array,\r\n\t\t\t\t\"arguments\": array,\r\n\t\t\t\tobject: function( map, stack ) {\r\n\t\t\t\t\tvar ret = [ ], keys, key, val, i;\r\n\t\t\t\t\tQUnit.jsDump.up();\r\n\t\t\t\t\tif ( Object.keys ) {\r\n\t\t\t\t\t\tkeys = Object.keys( map );\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tkeys = [];\r\n\t\t\t\t\t\tfor ( key in map ) {\r\n\t\t\t\t\t\t\tkeys.push( key );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tkeys.sort();\r\n\t\t\t\t\tfor ( i = 0; i < keys.length; i++ ) {\r\n\t\t\t\t\t\tkey = keys[ i ];\r\n\t\t\t\t\t\tval = map[ key ];\r\n\t\t\t\t\t\tret.push( QUnit.jsDump.parse( key, \"key\" ) + \": \" + QUnit.jsDump.parse( val, undefined, stack ) );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tQUnit.jsDump.down();\r\n\t\t\t\t\treturn join( \"{\", ret, \"}\" );\r\n\t\t\t\t},\r\n\t\t\t\tnode: function( node ) {\r\n\t\t\t\t\tvar a, val,\r\n\t\t\t\t\t\topen = QUnit.jsDump.HTML ? \"&lt;\" : \"<\",\r\n\t\t\t\t\t\tclose = QUnit.jsDump.HTML ? \"&gt;\" : \">\",\r\n\t\t\t\t\t\ttag = node.nodeName.toLowerCase(),\r\n\t\t\t\t\t\tret = open + tag;\r\n\r\n\t\t\t\t\tfor ( a in QUnit.jsDump.DOMAttrs ) {\r\n\t\t\t\t\t\tval = node[ QUnit.jsDump.DOMAttrs[a] ];\r\n\t\t\t\t\t\tif ( val ) {\r\n\t\t\t\t\t\t\tret += \" \" + a + \"=\" + QUnit.jsDump.parse( val, \"attribute\" );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn ret + close + open + \"/\" + tag + close;\r\n\t\t\t\t},\r\n\t\t\t\tfunctionArgs: function( fn ) {//function calls it internally, it's the arguments part of the function\r\n\t\t\t\t\tvar args,\r\n\t\t\t\t\t\tl = fn.length;\r\n\r\n\t\t\t\t\tif ( !l ) {\r\n\t\t\t\t\t\treturn \"\";\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\targs = new Array(l);\r\n\t\t\t\t\twhile ( l-- ) {\r\n\t\t\t\t\t\targs[l] = String.fromCharCode(97+l);//97 is 'a'\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn \" \" + args.join( \", \" ) + \" \";\r\n\t\t\t\t},\r\n\t\t\t\tkey: quote, //object calls it internally, the key part of an item in a map\r\n\t\t\t\tfunctionCode: \"[code]\", //function calls it internally, it's the content of the function\r\n\t\t\t\tattribute: quote, //node calls it internally, it's an html attribute value\r\n\t\t\t\tstring: quote,\r\n\t\t\t\tdate: quote,\r\n\t\t\t\tregexp: literal, //regex\r\n\t\t\t\tnumber: literal,\r\n\t\t\t\t\"boolean\": literal\r\n\t\t\t},\r\n\t\t\tDOMAttrs: {\r\n\t\t\t\t//attributes to dump from nodes, name=>realName\r\n\t\t\t\tid: \"id\",\r\n\t\t\t\tname: \"name\",\r\n\t\t\t\t\"class\": \"className\"\r\n\t\t\t},\r\n\t\t\tHTML: false,//if true, entities are escaped ( <, >, \\t, space and \\n )\r\n\t\t\tindentChar: \"  \",//indentation unit\r\n\t\t\tmultiline: true //if true, items in a collection, are separated by a \\n, else just a space.\r\n\t\t};\r\n\r\n\treturn jsDump;\r\n}());\r\n\r\n// from Sizzle.js\r\nfunction getText( elems ) {\r\n\tvar i, elem,\r\n\t\tret = \"\";\r\n\r\n\tfor ( i = 0; elems[i]; i++ ) {\r\n\t\telem = elems[i];\r\n\r\n\t\t// Get the text from text nodes and CDATA nodes\r\n\t\tif ( elem.nodeType === 3 || elem.nodeType === 4 ) {\r\n\t\t\tret += elem.nodeValue;\r\n\r\n\t\t// Traverse everything else, except comment nodes\r\n\t\t} else if ( elem.nodeType !== 8 ) {\r\n\t\t\tret += getText( elem.childNodes );\r\n\t\t}\r\n\t}\r\n\r\n\treturn ret;\r\n}\r\n\r\n// from jquery.js\r\nfunction inArray( elem, array ) {\r\n\tif ( array.indexOf ) {\r\n\t\treturn array.indexOf( elem );\r\n\t}\r\n\r\n\tfor ( var i = 0, length = array.length; i < length; i++ ) {\r\n\t\tif ( array[ i ] === elem ) {\r\n\t\t\treturn i;\r\n\t\t}\r\n\t}\r\n\r\n\treturn -1;\r\n}\r\n\r\n/*\r\n * Javascript Diff Algorithm\r\n *  By John Resig (http://ejohn.org/)\r\n *  Modified by Chu Alan \"sprite\"\r\n *\r\n * Released under the MIT license.\r\n *\r\n * More Info:\r\n *  http://ejohn.org/projects/javascript-diff-algorithm/\r\n *\r\n * Usage: QUnit.diff(expected, actual)\r\n *\r\n * QUnit.diff( \"the quick brown fox jumped over\", \"the quick fox jumps over\" ) == \"the  quick <del>brown </del> fox <del>jumped </del><ins>jumps </ins> over\"\r\n */\r\nQUnit.diff = (function() {\r\n\tfunction diff( o, n ) {\r\n\t\tvar i,\r\n\t\t\tns = {},\r\n\t\t\tos = {};\r\n\r\n\t\tfor ( i = 0; i < n.length; i++ ) {\r\n\t\t\tif ( ns[ n[i] ] == null ) {\r\n\t\t\t\tns[ n[i] ] = {\r\n\t\t\t\t\trows: [],\r\n\t\t\t\t\to: null\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tns[ n[i] ].rows.push( i );\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; i < o.length; i++ ) {\r\n\t\t\tif ( os[ o[i] ] == null ) {\r\n\t\t\t\tos[ o[i] ] = {\r\n\t\t\t\t\trows: [],\r\n\t\t\t\t\tn: null\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t\tos[ o[i] ].rows.push( i );\r\n\t\t}\r\n\r\n\t\tfor ( i in ns ) {\r\n\t\t\tif ( !hasOwn.call( ns, i ) ) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif ( ns[i].rows.length == 1 && typeof os[i] != \"undefined\" && os[i].rows.length == 1 ) {\r\n\t\t\t\tn[ ns[i].rows[0] ] = {\r\n\t\t\t\t\ttext: n[ ns[i].rows[0] ],\r\n\t\t\t\t\trow: os[i].rows[0]\r\n\t\t\t\t};\r\n\t\t\t\to[ os[i].rows[0] ] = {\r\n\t\t\t\t\ttext: o[ os[i].rows[0] ],\r\n\t\t\t\t\trow: ns[i].rows[0]\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor ( i = 0; i < n.length - 1; i++ ) {\r\n\t\t\tif ( n[i].text != null && n[ i + 1 ].text == null && n[i].row + 1 < o.length && o[ n[i].row + 1 ].text == null &&\r\n\t\t\t\t\t\tn[ i + 1 ] == o[ n[i].row + 1 ] ) {\r\n\r\n\t\t\t\tn[ i + 1 ] = {\r\n\t\t\t\t\ttext: n[ i + 1 ],\r\n\t\t\t\t\trow: n[i].row + 1\r\n\t\t\t\t};\r\n\t\t\t\to[ n[i].row + 1 ] = {\r\n\t\t\t\t\ttext: o[ n[i].row + 1 ],\r\n\t\t\t\t\trow: i + 1\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfor ( i = n.length - 1; i > 0; i-- ) {\r\n\t\t\tif ( n[i].text != null && n[ i - 1 ].text == null && n[i].row > 0 && o[ n[i].row - 1 ].text == null &&\r\n\t\t\t\t\t\tn[ i - 1 ] == o[ n[i].row - 1 ]) {\r\n\r\n\t\t\t\tn[ i - 1 ] = {\r\n\t\t\t\t\ttext: n[ i - 1 ],\r\n\t\t\t\t\trow: n[i].row - 1\r\n\t\t\t\t};\r\n\t\t\t\to[ n[i].row - 1 ] = {\r\n\t\t\t\t\ttext: o[ n[i].row - 1 ],\r\n\t\t\t\t\trow: i - 1\r\n\t\t\t\t};\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn {\r\n\t\t\to: o,\r\n\t\t\tn: n\r\n\t\t};\r\n\t}\r\n\r\n\treturn function( o, n ) {\r\n\t\to = o.replace( /\\s+$/, \"\" );\r\n\t\tn = n.replace( /\\s+$/, \"\" );\r\n\r\n\t\tvar i, pre,\r\n\t\t\tstr = \"\",\r\n\t\t\tout = diff( o === \"\" ? [] : o.split(/\\s+/), n === \"\" ? [] : n.split(/\\s+/) ),\r\n\t\t\toSpace = o.match(/\\s+/g),\r\n\t\t\tnSpace = n.match(/\\s+/g);\r\n\r\n\t\tif ( oSpace == null ) {\r\n\t\t\toSpace = [ \" \" ];\r\n\t\t}\r\n\t\telse {\r\n\t\t\toSpace.push( \" \" );\r\n\t\t}\r\n\r\n\t\tif ( nSpace == null ) {\r\n\t\t\tnSpace = [ \" \" ];\r\n\t\t}\r\n\t\telse {\r\n\t\t\tnSpace.push( \" \" );\r\n\t\t}\r\n\r\n\t\tif ( out.n.length === 0 ) {\r\n\t\t\tfor ( i = 0; i < out.o.length; i++ ) {\r\n\t\t\t\tstr += \"<del>\" + out.o[i] + oSpace[i] + \"</del>\";\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif ( out.n[0].text == null ) {\r\n\t\t\t\tfor ( n = 0; n < out.o.length && out.o[n].text == null; n++ ) {\r\n\t\t\t\t\tstr += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < out.n.length; i++ ) {\r\n\t\t\t\tif (out.n[i].text == null) {\r\n\t\t\t\t\tstr += \"<ins>\" + out.n[i] + nSpace[i] + \"</ins>\";\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\t// `pre` initialized at top of scope\r\n\t\t\t\t\tpre = \"\";\r\n\r\n\t\t\t\t\tfor ( n = out.n[i].row + 1; n < out.o.length && out.o[n].text == null; n++ ) {\r\n\t\t\t\t\t\tpre += \"<del>\" + out.o[n] + oSpace[n] + \"</del>\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstr += \" \" + out.n[i].text + nSpace[i] + pre;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn str;\r\n\t};\r\n}());\r\n\r\n// for CommonJS enviroments, export everything\r\nif ( typeof exports !== \"undefined\" ) {\r\n\textend(exports, QUnit);\r\n}\r\n\r\n// get at whatever the global object is, like window in browsers\r\n}( (function() {return this;}.call()) ));"]],"start1":0,"start2":0,"length1":0,"length2":53680}]],"length":53680,"saved":false}
